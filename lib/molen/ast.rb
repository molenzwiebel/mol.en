
# The AST (Abstract Syntax Tree). Basically the internal representation of 
# any mol.en file. This tree is generated by the parser.
module Molen
    class Visitor
    end

    class ASTNode
        attr_accessor :line_number, :column_number, :parent

        def self.inherited(klass)
            name = klass.name.split('::').last.downcase

            klass.class_eval %Q(
                def accept(visitor)
                    visitor.visit_#{name} self
                end
            )

            Visitor.class_eval %Q(
                def visit_#{name}(node)
                end
            )
        end
    end

    class Expression < ASTNode
    end

    class Statement < ASTNode
    end

    class Body < Expression
        attr_accessor :nodes

        def self.from(obj, auto_return = false)
            case obj
            when nil
                Body.new
            when Body
                obj
            when ::Array
                Body.new obj, auto_return
            else
                Body.new [obj], auto_return
            end
        end

        def initialize(nodes = [], auto_return = false)
            @nodes = nodes
            if auto_return and @nodes.size > 0 and @nodes.last.is_a? Expression then
                @nodes << Return.new(@nodes.pop)
            end
            @nodes.each { |e| e.parent = self }
        end

        def ==(other)
            other.class == self.class && other.nodes == nodes
        end

        def empty?
            nodes.size == 0
        end

        # If this body definitely returns. This means that the body always has a return statement somewhere.
        # If this is true, then the implicit return does not get generated and if and while branches do not
        # branch back.
        def definitely_returns
            does_return = false
            nodes.each do |node|
                returns = node.is_a?(Return)
                if node.is_a?(If) then
                    all_return = false
                    all_return = node.then.definitely_returns if node.else.empty?
                    all_return = (node.then.definitely_returns and node.else.definitely_returns) unless node.else.empty?
                    all_return = all_return && (node.elseifs.select{|x| x.last.definitely_returns}.size == node.elseifs.size)

                    returns = all_return
                end
                does_return ||= returns
            end
            does_return
        end
    end

    class Bool < Expression
        attr_accessor :value

        def initialize(val)
            @value = val.to_s == "true"
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class Int < Expression
        attr_accessor :value

        def initialize(val)
            @value = val.to_i
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class Double < Expression
        attr_accessor :value

        def initialize(val)
            @value = val.to_f
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class Str < Expression
        attr_accessor :value

        def initialize(val)
            @value = val
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class Null < Expression
        def ==(other)
            other.class == self.class
        end
    end

    class Call < Expression
        attr_accessor :name, :args, :on

        def initialize(func_name, args = [], on = nil)
            @name = func_name
            @args = args
            @args.each { |arg| arg.parent = self }
            @on = on
            @on.parent = self if on
        end

        def ==(other)
            other.class == self.class && other.args == args && other.name == name && other.on == on
        end
    end

    class Member < Expression
        attr_accessor :parent, :child

        def initialize(parent, child)
            @parent = parent
            @child = child
        end

        def ==(other)
            other.class == self.class && other.parent == parent && other.child == child
        end
    end

    class New < Expression
        attr_accessor :name, :args

        def initialize(name, args = [])
            @name = name
            @args = args
            @args.each { |arg| arg.parent = self }
        end

        def ==(other)
            other.class == self.class && other.name == name && other.args == args
        end
    end

    class Var < Expression
        attr_accessor :value

        def initialize(val)
            @value = val
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class Binary < Expression
        attr_accessor :op, :left, :right

        def initialize(op, left, right)
            @op = op
            @left = left
            @left.parent = self
            @right = right
            @right.parent = self
        end

        def ==(other)
            other.class == self.class && other.op == op && other.left == left && other.right == right
        end
    end

    class Arg < Expression
        attr_accessor :name, :type

        def initialize(name, type)
            @name = name
            @type = type
        end

        def ==(other)
            other.class == self.class && other.name == name && other.type == type
        end
    end

    class Function < Statement
        attr_accessor :name, :ret_type, :args, :body

        def initialize(name, ret_type = nil, args = [], body = nil)
            @name = name
            @ret_type = ret_type
            @args = args
            @args.each {|arg| arg.parent = self}
            @body = Body.from body
            @body.parent = self
        end

        def ==(other)
            other.class == self.class && other.name == name && other.args == args && other.body == body
        end
    end

    class If < Statement
        attr_accessor :cond, :then, :elseifs, :else

        def initialize(cond, if_then, if_else = nil, elseifs = [])
            @cond = cond
            @cond.parent = self
            @then = Body.from if_then
            @then.parent = self
            @elseifs = elseifs.map {|else_if| [else_if.first, Body.from(else_if.last)]} if elseifs
            @elseifs.each {|else_if| else_if.first.parent = self; else_if.last.parent = self} if elseifs
            @else = Body.from if_else
            @else.parent = self
        end

        def ==(other)
            other.class == self.class && other.cond == cond && other.then == @then && other.elseifs == elseifs && other.else == @else
        end
    end

    class For < Statement
        attr_accessor :init, :cond, :step, :body

        def initialize(cond, init = nil, step = nil, body = nil)
            @cond = cond
            @cond.parent = self
            @init = init
            @init.parent = self if init
            @step = step
            @step.parent = self if step
            @body = Body.from body
            @body.parent = self
        end

        def ==(other)
            other.class == self.class && other.init == init && other.cond == cond && other.step == step && other.body == body
        end
    end

    class VarDef < Statement
        attr_accessor :name, :type, :value

        def initialize(name, type = nil, value = nil)
            @name = name
            @name.parent = self
            @type = type
            @value = value
            @value.parent = self if value
        end

        def ==(other)
            other.class == self.class && other.name == name && other.value == value
        end
    end

    class Return < Statement
        attr_accessor :value

        def initialize(value = nil)
            @value = value
            @value.parent = self if value
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class ClassDef < Statement
        attr_accessor :name, :superclass, :vars, :funcs

        def initialize(name, superclass = nil, var_defs = [], funcs = [])
            @name = name
            @superclass = superclass
            @vars = var_defs
            @vars.each {|var| var.parent = self}
            @funcs = funcs
            @funcs.each {|func| func.parent = self}
        end

        def ==(other)
            other.class == self.class && other.name == name && other.superclass == superclass && other.vars == vars && other.funcs = funcs
        end
    end
end