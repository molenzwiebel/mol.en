
# The AST (Abstract Syntax Tree). Basically the internal representation of 
# any mol.en file. This tree is generated by the parser.
module Molen
    class Visitor
        def visit_any(node)
            nil
        end
    end

    class ASTNode
        attr_accessor :line_number, :column_number, :parent

        def self.inherited(klass)
            name = klass.name.split('::').last.downcase

            klass.class_eval %Q(
                def accept(visitor)
                    ret1 = visitor.visit_any self
                    ret2 = visitor.visit_#{name} self
                    return ret1 if ret1
                    ret2
                end
            )

            Visitor.class_eval %Q(
                def visit_#{name}(node)
                    nil
                end
            )
        end
    end

    class Expression < ASTNode
    end

    class Statement < ASTNode
    end

    class Body < Expression
        attr_accessor :nodes

        def self.from(obj, auto_return = false)
            case obj
            when nil
                Body.new
            when Body
                obj
            when ::Array
                Body.new obj, auto_return
            else
                Body.new [obj], auto_return
            end
        end

        def initialize(nodes = [], auto_return = false)
            @nodes = nodes
            if auto_return and @nodes.size > 0 and @nodes.last.is_a? Expression then
                @nodes << Return.new(@nodes.pop)
            end
            @nodes.each { |e| e.parent = self }
        end

        def ==(other)
            other.class == self.class && other.nodes == nodes
        end

        def empty?
            nodes.size == 0
        end

        # If this body definitely returns. This means that the body always has a return statement somewhere.
        # If this is true, then the implicit return does not get generated and if and while branches do not
        # branch back.
        def definitely_returns
            does_return = false
            nodes.each do |node|
                returns = node.is_a?(Return)
                if node.is_a?(If) then
                    all_return = false
                    all_return = node.then.definitely_returns if node.else.empty?
                    returns = (node.then.definitely_returns and node.else.definitely_returns) unless node.else.empty?
                end
                does_return ||= returns
            end
            does_return
        end
    end

    # This is never parsed by the parser and instead exists so that we can
    # control codegen at a certain point. The code generator will simply
    # execute the block specified when creating this. This constructor
    # requires a type so that the return type of a call can be accurately
    # deduced by the typing visitor.
    class RubyBody < ASTNode
        attr_accessor :block

        def initialize(type, block)
            @type = type
            @block = block
        end
    end

    class Bool < Expression
        attr_accessor :value

        def initialize(val)
            @value = val.to_s == "true"
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class Int < Expression
        attr_accessor :value

        def initialize(val)
            @value = val.to_i
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class Double < Expression
        attr_accessor :value

        def initialize(val)
            @value = val.to_f
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class Str < Expression
        attr_accessor :value

        def initialize(val)
            @value = val
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class Null < Expression
        def ==(other)
            other.class == self.class
        end
    end

    class Call < Expression
        attr_accessor :name, :args, :on

        def initialize(func_name, args = [], on = nil)
            @name = func_name
            @args = args
            @args.each { |arg| arg.parent = self }
            @on = on
            @on.parent = self if on
        end

        def ==(other)
            other.class == self.class && other.args == args && other.name == name && other.on == on
        end
    end

    class Member < Expression
        attr_accessor :on, :child

        def initialize(on, child)
            @on = on
            @child = child
        end

        def ==(other)
            other.class == self.class && other.on == on && other.child == child
        end
    end

    class New < Expression
        attr_accessor :name, :args

        def initialize(name, args = [])
            @name = name
            @args = args
            @args.each { |arg| arg.parent = self }
        end

        def ==(other)
            other.class == self.class && other.name == name && other.args == args
        end
    end

    class Var < Expression
        attr_accessor :value

        def initialize(val)
            @value = val
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class Assign < Expression
        attr_accessor :name, :value

        def initialize(name, value)
            @name = name
            @name.parent = name
            @value = value
            @value.parent = value
        end

        def ==(other)
            other.class == self.class && other.name == name && other.value == value
        end
    end

    class Arg < Expression
        attr_accessor :name, :type

        def initialize(name, type)
            @name = name
            @type = type
        end

        def ==(other)
            other.class == self.class && other.name == name && other.type == type
        end
    end

    class Function < Statement
        attr_accessor :name, :ret_type, :args, :body

        def initialize(name, ret_type = nil, args = [], body = nil)
            @name = name
            @ret_type = ret_type
            @args = args
            @args.each {|arg| arg.parent = self}
            @body = Body.from body
            @body.parent = self
        end

        def ==(other)
            other.class == self.class && other.name == name && other.args == args && other.body == body
        end
    end

    class If < Statement
        attr_accessor :cond, :then, :else

        def initialize(cond, if_then, if_else = nil, elseifs = [])
            @cond = cond
            @cond.parent = self
            @then = Body.from if_then
            @then.parent = self

            else_body = Body.from if_else
            elseifs.reverse.each do |else_if|
                else_body = If.new else_if.first, else_if.last, else_body
            end

            @else = Body.from else_body
            @else.parent = self
        end

        def ==(other)
            other.class == self.class && other.cond == cond && other.then == @then && other.else == @else
        end

        def definitely_returns
            returns = self.then.definitely_returns
            returns = (returns and self.else.definitely_returns) unless self.else.empty?
            returns
        end
    end

    class For < Statement
        attr_accessor :init, :cond, :step, :body

        def initialize(cond, init = nil, step = nil, body = nil)
            @cond = cond
            @cond.parent = self
            @init = init
            @init.parent = self if init
            @step = step
            @step.parent = self if step
            @body = Body.from body
            @body.parent = self
        end

        def ==(other)
            other.class == self.class && other.init == init && other.cond == cond && other.step == step && other.body == body
        end
    end

    class VarDef < Statement
        attr_accessor :name, :type, :value

        def initialize(name, type = nil, value = nil)
            @name = name
            @name.parent = self
            @type = type
            @value = value
            @value.parent = self if value
        end

        def ==(other)
            other.class == self.class && other.name == name && other.value == value
        end
    end

    class Return < Statement
        attr_accessor :value

        def initialize(value = nil)
            @value = value
            @value.parent = self if value
        end

        def ==(other)
            other.class == self.class && other.value == value
        end
    end

    class ClassDef < Statement
        attr_accessor :name, :superclass, :vars, :funcs

        def initialize(name, superclass = nil, var_defs = [], funcs = [])
            @name = name
            @superclass = superclass || "Object"
            @vars = var_defs
            @vars.each {|var| var.parent = self}
            @funcs = funcs
            @funcs.each {|func| func.parent = self}
        end

        def ==(other)
            other.class == self.class && other.name == name && other.superclass == superclass && other.vars == vars && other.funcs = funcs
        end
    end
end