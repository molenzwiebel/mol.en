#!/usr/bin/env ruby
require 'bundler/setup'
require_relative '../lib/molen'
require 'optparse'
require 'colorize'

require 'llvm/execution_engine'
require 'llvm/transforms/scalar'
require 'llvm/transforms/ipo'
require 'llvm/transforms/vectorize'
require 'llvm/transforms/builder'

options = {}
OptionParser.new do |opts|
    opts.on('-o', '--output FILENAME', "Output filename") do |output|
        options[:output] = output
    end

    opts.on('-O', '--optimize AMOUNT', "How many optimize passes need to be ran") do |opt|
        options[:optimize] = opt.to_i
    end

    opts.on_tail('-g', '--graph', "Create a graph of the provided source") do |graph|
        options[:graph] = graph
    end

    opts.on('-e', '--execute SRC', "Single line of source code") do |src|
        options[:src] = src
    end

    opts.on_tail('-u', '--dump', "Output LLVM IR to stderr") do
        options[:dump_ir] = true
    end

    opts.on_tail('-x', '--exit', "Do not compile or execute the code") do
        options[:do_not_run] = true
    end

    opts.on_tail('-v', '--no-validate', "Do not validate the generated LLVM IR") do
        options[:no_validate] = true
    end

    opts.on_tail('-h', '--help', "Help") do
        puts opts
        exit
    end

    opts.on_tail("-c", "Open REPL with mol.en loaded.") do
        require 'irb'
        require 'llvm/core'
        require 'ruby-graphviz'
        include Molen
        ARGV.clear
        IRB.start
    end
end.parse!

LLVM.init_jit

begin
    input = options[:src] ? options[:src] : ARGF.read

    puts "[+] Parsing input...".green
    body = Molen.parse input
    puts "[+] Parsing complete. Body with #{body.nodes.size} elements parsed.".green

    if options[:graph] then
        include Molen
        puts "[+] Creating graph.".green
        Molen.graph body, options[:graph]
        puts "[+] Graph saved to #{options[:graph]}.png".green
    end

    mod = Molen::Module.new

    puts "[+] Typing input...".green
    Molen.type body, mod
    puts "[+] Done typing input.".green

    puts "[+] Generating LLVM IR...".green
    llvm_mod = Molen.gen body, mod
    llvm_mod.verify unless options[:no_validate]
    puts "[+] Generated LLVM IR.".green

    llvm_mod.dump if options[:dump_ir]

    puts "[+] Optimizing LLVM IR...".green
    engine = LLVM::JITCompiler.new llvm_mod
    optimize = LLVM::PassManager.new engine
    optimize << :arg_promote << :gdce << :global_opt << :gvn << :reassociate << :instcombine << :basicaa << :jump_threading << :simplifycfg << :inline << :mem2reg
    (options[:optimize] || 5).times { optimize.run llvm_mod }
    puts "[+] Optimized LLVM IR.".green

    exit if options[:do_not_run]
    if options[:output] then
        puts "[+] Compiling to file #{options[:output]}...".green
        $stderr.reopen "#{options[:output]}.ll", "w"
        llvm_mod.dump
        cmd = "clang -o #{options[:output]} -x ir #{options[:output]}.ll"
        pid = spawn cmd
        Process.waitpid pid
        File.delete "#{options[:output]}.ll"
        puts "[+] Done!".green
    else
        puts "[+] Running...".green
        ret = engine.run_function llvm_mod.functions["main"]
        puts "[+] Done! JIT returned with code #{ret.to_i}".green
    end
rescue StandardError => ex
    puts "[-] Failed: #{ex.to_s}".red
    puts "[-] Backtrace:\n\t#{ex.backtrace.join("\n\t")}".red
end